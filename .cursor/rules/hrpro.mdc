You are working inside the Interview Assistant project.

Interview Assistant is an Electron-based desktop application for HR specialists that provides real-time interview transcription, AI-powered candidate analysis, and insights for decision-making. The system operates as a standalone desktop application without requiring external backend services.

---

## Project tasks

1. Provide a live transcript of the interview.
2. Analyze candidate answers using an LLM and the job knowledge base (Job Description, tech stack).
3. Give HR short hints: strengths/weaknesses, risk areas, shallow answers, possible inconsistencies.
4. Suggest clarifying follow-up questions to check the candidate’s knowledge depth.
5. Save a final report (summary, strengths, risks, follow-ups, scores) in text format for HR.

**Important:**

* Do not directly accuse the candidate of using AI. Instead, note only indicators such as: "shallow," "generic," "no examples," "perfectly phrased but no details."
* Answers must be short, structured, in JSON or Markdown format (depending on task).
* Data is used only to help HR; the final decision remains with the human.
* Style: neutral, professional, no marketing phrases.
* Interviews average 1 hour. Latency must be low: insights every 2–4 seconds in small chunks.

**CRITICAL RULE - NO FAKE DATA:**

* NEVER EVER USE DEMO DATA, SIMULATIONS, OR FAKE RESULTS!!!!!!!!!!!!!!!!!!!!
* ALL testing must use REAL APIs, REAL audio processing, REAL transcription services!!!!!!!!!!!!!!!!!!!!
* NO pre-written sample texts, NO simulated confidence scores, NO fake quality metrics!!!!!!!!!!!!!!!!!!!!
* If testing transcription quality - use REAL Whisper API vs REAL Deepgram results!!!!!!!!!!!!!!!!!!!!
* Users expect REAL functionality, not demonstrations or simulations!!!!!!!!!!!!!!!!!!!!
* Any demo/simulation must be explicitly labeled as such and never presented as real results!!!!!!!!!!!!!!!!!!!!!

---

## Current Architecture (v0.51)

**Desktop Application:** Electron + React/TypeScript

* **Main Process:** Window management, IPC handlers, global shortcuts
* **Renderer Process:** React UI with modular components
* **Preload Script:** Secure API bridge between main and renderer
* **Always-on-top, frameless, transparent windows** (macOS vibrancy / Windows layered)

**Audio Processing:**

* **AudioWorklet:** Real-time PCM processing (Float32 → Int16 conversion)
* **AudioContext:** 16kHz sample rate, single channel
* **Microphone capture:** getUserMedia with optimized constraints
* **Real-time audio analysis:** Level monitoring and visualization

**Speech Recognition:** Deepgram Streaming API

* **Model:** nova-2-meeting (optimized for interview context)
* **Settings:** Auto language detection, punctuation, smart formatting
* **Partial results:** Every 100-250ms for real-time feedback
* **Final results:** After 300-800ms silence (adaptive endpointing)
* **Adaptive ASR:** Dynamic parameter optimization based on confidence

**AI Analysis:** Claude Sonnet 4

* **Model:** claude-sonnet-4-20250514
* **Context window:** Last 15-40 seconds of transcript (adaptive)
* **Output format:** JSON with topic, depth_score, signals, followups
* **Rate limiting:** 3 requests/second with timeout protection

**Post-Processing:** ASR Correction System

* **Model:** claude-3-haiku-20240307 (fast correction)
* **Triggers:** Low confidence, technical terms, mixed language
* **Processing time:** <500ms timeout
* **Fallback:** Original text on error

**RAG System:** Context Enhancement

* **Document processing:** Job descriptions, requirements, tech stack
* **Embeddings:** Local vector storage for relevant context
* **Context injection:** Enhanced prompts with relevant information

**Data Storage:** Local File System

* **Transcript logs:** Markdown files in `transcript-logs/` directory
* **Session metadata:** JSON format with timestamps and confidence scores
* **No external database:** All data stored locally for privacy

---

## Architecture Flow (Current Implementation)

**Audio Pipeline:**
Microphone → AudioWorklet (PCM processing) → Deepgram WebSocket → Real-time transcript

**Analysis Pipeline:**
Transcript segments → Claude AI analysis → RAG context enhancement → Insights generation

**UI Synchronization:**
Control Panel (recording) → IPC → Data Window (display) → Real-time updates

**Data Flow:**
1. **Audio Capture:** getUserMedia → AudioContext → AudioWorkletNode
2. **Speech Recognition:** PCM data → Deepgram API → Partial/Final transcripts
3. **AI Analysis:** Transcript → Claude API → Insights (strength/risk/question)
4. **Post-Processing:** Low confidence segments → Correction system
5. **UI Updates:** State changes → IPC → Window synchronization
6. **Logging:** All events → Local markdown files

**Window Management:**
- **Control Panel:** Compact recording interface (200x56px)
- **Data Window:** Full transcript and insights display (600x400px)
- **IPC Communication:** Secure data transfer between windows
- **Global Shortcuts:** Ctrl+\ for show/hide functionality

---

## Implementation Status (Current: v0.51)

### ✅ Sprint 1: Core Desktop Application (COMPLETED)

* **Electron Application:** Always-on-top, transparent, frameless windows
* **Global Shortcuts:** Ctrl+\ for show/hide functionality
* **Audio Capture:** getUserMedia with optimized constraints
* **Deepgram Integration:** Real-time streaming transcription
* **Basic UI:** Control panel and data window components

### ✅ Sprint 2: Modular Architecture & AI Analysis (COMPLETED)

* **Modular Components:** UI split into ui/, control/, data/ modules
* **Modular Hooks:** useTranscription broken into specialized hooks
* **Claude AI Integration:** Real-time analysis with context enhancement
* **RAG System:** Document processing and context injection
* **Post-Editor:** ASR correction for low-confidence segments
* **IPC Communication:** Secure data synchronization between windows

### ✅ Sprint 3: Advanced Features (COMPLETED)

* **Adaptive ASR:** Dynamic parameter optimization
* **Error Handling:** Comprehensive error management with fallbacks
* **Security:** Context isolation, secure preload scripts
* **Logging:** Local transcript storage in markdown format
* **Performance:** AudioWorklet for real-time processing

### 🔄 Sprint 4: Future Enhancements (PLANNED)

* **Speaker Diarization:** Separate candidate vs interviewer speech
* **Advanced Analytics:** Temporal signals, pace analysis
* **Export Features:** PDF reports, data export
* **Multi-language Support:** Enhanced language detection
* **Performance Optimization:** Further latency improvements

---

## Prompts (Claude / LLM)

**System (speech analysis):**

* Classify topic
* Score depth 0–1
* Detect risks (generic, inconsistent, “perfect”)
* Suggest 1–2 follow-up questions
* Never accuse of cheating, only note indicators
* Strict JSON output (<120 chars hints)

**User (every tick):**

* JD context
* Last 15–40s transcript (adaptive)
* Entities memory (last 20 terms)
* History of topics/risks
* Must return JSON with topic, depth\_score, signals, followups, note

**Post-interview report:**

* Markdown with Summary, Strengths, Risks (with timestamps), Follow-ups, Scores, Red flags.

---

## Event Schema (Current Implementation)

**IPC Events:**
* `transcript-update` — Real-time transcript data
* `insights-update` — AI-generated insights
* `recording-state-change` — Recording status updates
* `window-created` — Window management events
* `window-closed` — Window cleanup events

**Transcript Events:**
* `partial` — Interim transcript results
* `final` — Confirmed transcript segments
* `corrected` — Post-editor corrections

**Analysis Events:**
* `insight` — New AI insight (strength/risk/question)
* `topic-change` — Subject matter transitions
* `confidence-update` — ASR confidence metrics

**System Events:**
* `error` — Error notifications
* `warning` — System warnings
* `info` — Status messages

---

## Electron Implementation Details

**Window Configuration:**
* **Transparent windows:** macOS vibrancy, Windows layered transparency
* **Always-on-top:** Stays above video call applications
* **Frameless design:** Custom UI without system chrome
* **Click-through:** Optional click-through mode for overlay behavior
* **Global shortcuts:** Ctrl+\ for show/hide functionality

**Security Features:**
* **Context isolation:** `contextIsolation: true`
* **No node integration:** `nodeIntegration: false`
* **Web security:** `webSecurity: true`
* **Preload scripts:** Secure API bridge between processes
* **API key protection:** Environment variables via preload

**Performance Optimizations:**
* **Background throttling disabled:** `backgroundThrottling: false`
* **AudioWorklet processing:** Real-time audio without main thread blocking
* **IPC optimization:** Efficient data transfer between windows
* **Memory management:** Proper cleanup of audio contexts and streams

---

## Latency & cost

* Target: streaming <900 ms total latency (p95)
* Costs: \~\$0.18–1.20/hr for ASR + a few cents for LLM

---

## Security

* Store only text + aggregates
* Mask PII
* Tokenized report links

---

## Roadmap upgrades

* Speaker diarization
* Temporal signals (delays, pace)
* Anti-spoof heuristics
* Zoom App version
* PDF export (Pro)

---

## Modular Architecture (v0.51 Refactoring)

**Component Structure:**
```
src/components/
├── ui/                    # Reusable UI components
│   ├── Button.tsx         # Generic button component
│   ├── Panel.tsx          # Container components
│   ├── Transcript.tsx     # Transcript display
│   └── Insights.tsx       # Insights display
├── control/               # Control panel components
│   ├── ControlPanel.tsx   # Main control interface
│   ├── StartButton.tsx    # Recording start button
│   ├── StopButton.tsx     # Recording stop button
│   └── DragZone.tsx       # Window drag area
├── data/                  # Data window components
│   ├── DataWindow.tsx     # Main data display
│   ├── TranscriptSection.tsx
│   └── InsightsSection.tsx
└── common/                # Shared components
    └── WaveLoader.tsx     # Audio visualization
```

**Hook Architecture:**
```
src/hooks/transcription/
├── index.ts                    # Main export
├── useTranscription.ts         # Simplified main hook
├── useTranscriptionCore.ts     # Core state management
├── useTranscriptionCallbacks.ts # Event handlers
├── useTranscriptionState.ts    # State management
├── useTranscriptionServices.ts # Service integration
└── useTranscriptionRecording.ts # Recording logic
```

**Service Interfaces:**
* **ITranscriptionService:** Deepgram integration contract
* **IAnalysisService:** Claude AI analysis contract
* **IConfigService:** Configuration management contract
* **IErrorHandler:** Error management contract

---

## Architecture Principles (Current Implementation)

**Modular Design:**
* **Component separation:** ui/, control/, data/ modules
* **Hook specialization:** useTranscriptionCore, useTranscriptionCallbacks, etc.
* **Service interfaces:** ITranscriptionService, IAnalysisService, IConfigService
* **Loose coupling:** Event-driven communication between modules

**Type Safety:**
* **Strict TypeScript:** Comprehensive type definitions
* **Interface contracts:** Well-defined API boundaries
* **Error handling:** AppError class with structured error management
* **Runtime validation:** Input validation and type checking

**Performance:**
* **Real-time processing:** AudioWorklet for non-blocking audio
* **Adaptive algorithms:** Dynamic ASR parameter optimization
* **Rate limiting:** API call throttling and timeout protection
* **Memory efficiency:** Proper resource cleanup and garbage collection

**Security:**
* **Process isolation:** Electron security best practices
* **API key protection:** Secure environment variable handling
* **Local storage:** No external data transmission
* **Input sanitization:** Safe handling of user data

---

## Testing pyramid

* Unit, contract, integration, e2e
* API facades with mocks
* Performance budgets enforced
* Security scans in CI

---

## Error Handling (Current Implementation)

**Error Management:**
* **AppError class:** Structured error handling with context
* **ErrorHandler utility:** Centralized error processing and retry logic
* **Fallback mechanisms:** Graceful degradation on service failures
* **Logging:** Comprehensive error logging with stack traces

**Recovery Strategies:**
* **API failures:** Automatic retry with exponential backoff
* **Audio issues:** Fallback to basic recording mode
* **Network problems:** Offline mode with local processing
* **Memory issues:** Automatic cleanup and resource management

**User Experience:**
* **Non-blocking errors:** UI remains responsive during failures
* **Error notifications:** Clear user feedback on issues
* **Recovery options:** Manual retry and reset functionality
* **Graceful shutdown:** Proper cleanup on application exit

---

## Compliance

* GDPR/DPIA
* SOC2/ISO later

---

## Documentation Status (v0.51)

**Current Documentation:**
* **Complete system documentation:** DOCS/DOCUMENTATION.md (2,349 lines)
* **Modular architecture guide:** Detailed component and hook documentation
* **API documentation:** Service interfaces and type definitions
* **Security guidelines:** Electron security best practices
* **Performance optimization:** AudioWorklet and ASR tuning guides

**Developer Resources:**
* **Setup instructions:** Environment configuration and dependencies
* **Architecture overview:** System flow and component relationships
* **Code examples:** Real implementation snippets with explanations
* **Troubleshooting:** Common issues and solutions
* **Extension guide:** How to add new features and modules

**Maintenance:**
* **Version tracking:** Current v0.51 with change history
* **Update procedures:** How to sync documentation with code changes
* **Code comments:** Inline documentation explaining design decisions
* **README files:** Module-specific setup and usage instructions

---

This document captures the Interview Assistant project v0.51 with current architecture, implementation status, and detailed technical specifications. The system is a fully functional Electron desktop application with modular architecture, real-time AI analysis, and comprehensive error handling.
